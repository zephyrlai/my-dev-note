## 05.MySQL事务与锁
### 一、MySQL事务管理
#### 1.1 概述
* 在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。
* 事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。
* 事务用来管理DDL、DML、DCL操作，比如 insert,update,delete 语句，默认是自动提交的。
* 事务应该具有的4个特性：ACID
    * __A__ tomicity（原子性）:构成事务的的所有操作必须是一个逻辑单元，要么全部执行，要么全部不执行。
    * __C__ onsistency（稳定性、一致性）:数据库在事务执行前后状态都必须是稳定的。例如对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNTS表中Tom和Jack的存款总额为2000元。
    * __I__ solation（隔离性）:事务之间不会相互影响。
    * __D__ urability（可靠性、持久性）:事务执行成功后必须全部写入磁盘，永久保存且不会被回滚。
#### 1.2 相关命令
常见的操作有一下三个：
* ```BEGIN```或```START TRANSACTION```；显式地开启一个事务；
* ```COMMIT```；也可以使用```COMMIT WORK```，不过二者是等价的。```COMMIT```会提交事务，并使已对数据库进行的所有修改称为永久性的；
* ```ROLLBACK```；有可以使用```ROLLBACK WORK```，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；  

在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行```COMMIT```操作。因此要显式地开启一个事务务须使用命令```BEGIN```或```START TRANSACTIO```，或者执行命令```SET AUTOCOMMIT=0```，用来禁止使用当前会话的自动提交。
#### 1.3 并发问题与隔离级别
3种并发问题：  
* 脏读是指一个事务读取到了其他事务没有提交的数据
* 不可重复读是指一个事务内多次根据同一个查询条件查询出来的同一行记录的值不一样
* 幻读是指一个事务内多次根据同个条件查出来的记录行数不一样。

为了解决事务并发带来的问题，才有了事务规范中的四个事务隔离级别，不同隔离级别对上面问题部分或者全部做了避免(正确性由低到高，性能从高到低）：
* Read uncommitted (读未提交)：最低级别，任何情况都无法保证。
* Read committed (读已提交)：可避免脏读的发生。
* Repeatable read (可重复读)：可避免脏读、不可重复读的发生。
* Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。

并发问题与隔离级别直接的关系：
| 隔离级别 \ 并发问题 | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read）|  
|:---|:---|:---|:---|  
| 未提交读（Read uncommitted） |  √  | √  | √ |  
| 已提交读（Read committed） | × | √  | √ |  
| 可重复读（Repeatable read） | × | × | √ |  
| 可串行化（Serializable ） | × | × | × |  

默认的隔离级别
* 大多数数据库的默认隔离级别是Read committed，比如Oracle、DB2等。
* MySQL数据库的默认隔离级别是Repeatable read。

如何查看和设置隔离级别：
* 在MySQL数据库中查看当前事务的隔离级别：
    ``` sql
    -- 语法规则：select @@tx_isolation;
    mysql> select @@tx_isolation;
    +-----------------+
    | @@tx_isolation  |
    +-----------------+
    | REPEATABLE-READ |
    +-----------------+
    1 row in set (0.00 sec)
    ```
* 在MySQL数据库中设置事务的隔离级别：
    ``` sql
    -- 语法规则：
    -- set  [glogal | session]  transaction isolation level 隔离级别名称;
    -- set tx_isolation=’隔离级别名称;’
    mysql> set session transaction isolation level read committed;
    Query OK, 0 rows affected (0.01 sec)

    mysql> select @@tx_isolation;
    +----------------+
    | @@tx_isolation |
    +----------------+
    | READ-COMMITTED |
    +----------------+
    1 row in set (0.00 sec)
    ```

### 二、MySQL的锁机制
#### 2.1 概述
数据库锁定机制简单来说就是数据库为了保证数据的一致性而使各种共享资源在被并发访问访问变得有序所设计的一种规则。  
总的来说，MySQL各存储引擎使用了三种类型（级别）的锁定机制：__行级锁定__，__页级锁定__ 和 __表级锁定__。
##### 2.1.1 独占锁、共享锁
MySQL的锁定有两种模式：__共享锁（读锁）__ 和 __独占锁（写锁）__。  
* 排他锁，也称写锁，独占锁，当前写操作没有完成前，它会阻断其他写锁和读锁。
* 共享锁，也称读锁，多用于判断数据是否存在，多个读操作可以同时进行而不会互相影响。当如果事务对读锁进行修改操作，很可能会造成死锁。
##### 2.1.2 行级锁
* 优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强；
* 缺陷：开销大；加锁慢；容易出现死锁；
* 加锁方式：对于UPDATE、DELETE和INSERT语句自动加锁，SELECT语句不会自动加锁，或者用如下方式为SELECT语句加锁；
    ``` sql
    -- 独占锁（写锁）
    select col1,col2 from table where col1=con1... for update;
    -- 共享锁（读锁）
    select col1,col2 from table where col1=con1... lock in share mode;
    ```
* InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，__否则都会从行锁升级为表锁。__
##### 2.1.3 表级锁
* 和行级锁定相反，表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。  
* 当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。
* MySQL 实现的表级锁定的争用状态变量：
    ``` sql
    mysql> show status like 'table_locks%';
    +----------------------------+-------+
    | Variable_name              | Value |
    +----------------------------+-------+
    | Table_locks_immediate      | 71    |
    | Table_locks_waited         | 0     |
    +----------------------------+-------+
    5 rows in set (0.02 sec)
    -- table_locks_immediate：产生表级锁定的次数；
    -- table_locks_waited：出现表级锁定争用而发生等待的次数；
    ```
* 手动增加表锁
    ``` sql
    lock table 表名称 read(write),表名称2 read(write),...;
    ```
* 查看表锁情况
    ``` sql
    show open tables;
    ```
* 删除表锁
    ``` sql
    unlock tables;
    ```
##### 2.1.4 页级锁(间隙锁)
开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发处理能力一般。只需了解一下。

#### 2.2 锁演示
需要开始手动提交事务模式
``` sql
set autocommit = 0;
```
##### 2.2.1 表级锁：
* 读锁  
    ![](images/0501.png)  
    ```
* 写锁
    ![](images/0502.png)
##### 2.2.2 行级锁(写锁自动添加，读锁手动添加)：
* 读锁
    ![](images/0503.png)
* 写锁
    ![](images/0504.png)
##### 2.2.4 行级锁自动升级为表级锁：
![](images/0505.png)
##### 2.2.5 间隙锁带来的插入问题演示
![](images/0506.png)
##### 2.2.6 使用共同索引导致不同数据阻塞演示

##### 2.2.7 死锁演示

#### 2.3 锁机制



>[何为脏读、不可重复读、幻读](http://ifeve.com/db_problem/)
>[MySQL 表锁和行锁机制](https://juejin.im/entry/5a55c7976fb9a01cba42786f)