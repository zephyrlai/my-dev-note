## 〇、目录
1. 什么是线程
1. 线程的创建与运行
1. 线程的通知与等待
1. 等待线程执行终止join的方法
1. 让线程睡眠的sleep方法
1. 让出CPU执行全的yield方法
1. 线程中断
1. 理解线程上下文切换
1. 线程死锁
1. 守护线程与用户线程
1. ThreadLocal

## 一、什么是线程
一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器和技区域 。
1. （线程的）程序计数器：
1. （线程的）栈内存：存放当前线程私有的局部变量，其他线程无法访问
1. （进程的）堆内存：堆是一个进程中最大的一块内存，堆是被进程中的所有线程共享的，是进程创建时分配的，堆里面主要存放用 new操作创建的对象实例。
1. （进程的）方法区：存放JVM加载的类、常量及静态变量等信息，也是线程共享的。

## 二、线程的创建与运行
常见的线程创建方式有如下3种
1. 继承Thread类，重写run方法，这样的好处是可以在线程类中自定义局部变量；
1. 实现Runnable接口，实现run方法（也可以通过匿名内部类的方法）；
1. 实现Callable接口，submit到线程池中或者传递给FutureTask类；

## 三、线程的通知与等待
【复习】线程状态：新建、就绪、运行、阻塞、消亡 
    ![](images/0102.png)
#### wait()方法

在调用锁对象的wait方法时，如果没有实现获取锁对象，则会抛```IllegalMonitorStateException```
#### wait(long timeout)方法
#### wait(long timeout,int nanos)方法
#### notify()方法
notify()方法的作用是随机唤醒一个通过相同锁对象调用wait方法而阻塞的线程，但这个线程并不是立即执行，而是需要与其他处于就绪状态的线程一样进行锁竞争，只有竞争到了锁才能继续执行（_nofity方法只是让处于阻塞状态的线程重新变为就绪状态，想要进入运行状态还需要cpu调度与锁竞争_）   
与wait方法一样，只有当前线程获取到了对应的锁对象，才能调用锁对象的notify方法，否则会抛```IllegalMonitorStateException```
#### notifyAll()方法
与notify方法类似，也是随机唤醒通过相同锁对象调用wait方法而阻塞的线程，只是这时唤醒的是对应的所有线程

## TODO：
1. FutureTask
1. 线程的虚假唤醒问题：  
    因为wait方法可以分为三个操作：
    （1）释放锁并阻塞
    （2）等待条件cond发生
    （3）获取通知后，竞争获取锁
1. 当前线程调用共享变量的 wait()方法后只会释放当前共享变量上 的锁，如果当前线程还持有其他共享变量的锁，则这些锁是不会被释放的。