### 一、 概述
* Redis的事务是通过```MULTI```，```EXEC```，```DISCARD```和```WATCH```这四个命令来完成的。
* Redis的单个命令都是原子性的，所以这里确保事务性的对象是命令集合。
* Redis事务是将 _命令集合_ 序列化并确保处于同一事务的命令集合连续且不被打断的执行
* Redis _不支持_ 回滚操作

### 二、相关命令及使用
#### 1. 概述
```MULTI```命令会标记事务块的开始，后续输入的Redis命令将被加入到事务块的队列中而不会被立即执行，在输入```EXEC```之后，redis会顺序地、原子地执行之前积压在事务块队列中的redis命令。```DISCARD```适合在```MULTI```之后、```EXEC```之前执行，表示清除当前事务块及事务块队列中的redis命令。```WATCH```命令则起到一个类似于乐观锁的作用，在```MULTI```之前输入。
#### 1. 相关命令
* MULTI：
    * 语法: ```MULTI```
    * 作用用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后使用EXEC命令原子化地执行这个命令序列。
* EXEC：
    * 语法: ```EXEC```
    * 作用在一个事务中执行所有先前放入队列的命令，然后恢复正常的连接状态
* DISCARD：
    * 语法: ```DISCARD```
    * 作用清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。
* WATCH：
    * 语法: ```WATCH key [key…]```
    * 作用当某个事务需要按条件执行时，就要使用这个命令将给定的键设置为受监控的状态（乐观锁）。
#### 1. 使用
``` sh
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set k01 v01
QUEUED
127.0.0.1:6379> set k02 v02
QUEUED
127.0.0.1:6379> exec
1) OK
2) OK
127.0.0.1:6379> get k01
"v01"
127.0.0.1:6379> get k02
"v02"
```
### 三、事务失败的处理
* Redis语法错误（可以理解为编译期错误，下例中执行的命令就是错的）
    ``` sh
    127.0.0.1:6379> multi
    OK
    127.0.0.1:6379> set k1
    (error) ERR wrong number of arguments for 'set' command
    ```
* Redis类型错误（可以理解为运行期错误，下例中新建了一个String类型的key，但后面却尝试对其执行lpush命令）
    ``` sh
    127.0.0.1:6379> multi
    OK
    127.0.0.1:6379> set k v
    QUEUED
    127.0.0.1:6379> lpush k age 18
    QUEUED
    127.0.0.1:6379> exec
    1) OK
    2) (error) WRONGTYPE Operation against a key holding the wrong kind of value
    ```
* 为什么redis不支持事务回滚？
    * 大多数事务失败是因为语法错误或者类型错误，这两种错误，在开发阶段都是可以预见的
    * redis为了性能方面就忽略了事务回滚